
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Identity Readiness Simulator</title>
    <meta name="description" content="ID Health Check" />
    <meta name="author" content="Lovable" />
    <link rel="icon" href="/lovable-uploads/6dd67a5e-06f5-44cb-b4da-17d1fb8030d8.png" type="image/png">
    <!-- Preconnect to font origins for faster DNS resolution -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Load fonts asynchronously to avoid render blocking -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    <noscript>
      <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    </noscript>

    <meta property="og:title" content="ID Health Check" />
    <meta property="og:description" content="ID Health Check" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@lovable_dev" />
    <meta name="twitter:image" content="https://lovable.dev/opengraph-image-p98pqg.png" />
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <script>
(function () {
  const PARENT_ORIGIN = 'https://www.adfixus.com';
  const APP_NAME = 'AdFixus-ROI-Calculator';
  const DEBUG_MODE = true; // Toggle for production
  
  // === LOGGING SYSTEM ===
  const Logger = {
    styles: {
      info: 'background: #3B82F6; color: white; padding: 2px 6px; border-radius: 3px; font-weight: bold;',
      success: 'background: #10B981; color: white; padding: 2px 6px; border-radius: 3px; font-weight: bold;',
      warn: 'background: #F59E0B; color: black; padding: 2px 6px; border-radius: 3px; font-weight: bold;',
      error: 'background: #EF4444; color: white; padding: 2px 6px; border-radius: 3px; font-weight: bold;',
      debug: 'background: #8B5CF6; color: white; padding: 2px 6px; border-radius: 3px; font-weight: bold;',
    },
    
    _format(level, message, data) {
      const timestamp = new Date().toISOString();
      const prefix = `[${APP_NAME}:iframe]`;
      return { timestamp, prefix, level, message, data };
    },
    
    _log(level, message, data = null) {
      if (!DEBUG_MODE && level === 'debug') return;
      const entry = this._format(level, message, data);
      const style = this.styles[level] || this.styles.info;
      
      console.groupCollapsed(
        `%c${entry.prefix} %c${level.toUpperCase()}%c ${message}`,
        'color: #6B7280;', style, 'color: inherit;'
      );
      console.log('‚è∞ Timestamp:', entry.timestamp);
      if (data !== null) console.log('üì¶ Data:', data);
      console.log('üîó Origin:', window.location.origin);
      console.trace('üìç Stack trace');
      console.groupEnd();
    },
    
    info: (msg, data) => Logger._log('info', msg, data),
    success: (msg, data) => Logger._log('success', msg, data),
    warn: (msg, data) => Logger._log('warn', msg, data),
    error: (msg, data) => Logger._log('error', msg, data),
    debug: (msg, data) => Logger._log('debug', msg, data),
    
    table: (label, data) => {
      console.groupCollapsed(`%c[${APP_NAME}:iframe] TABLE: ${label}`, 'color: #6B7280; font-weight: bold;');
      console.table(data);
      console.groupEnd();
    },
    
    performance: (label, startTime) => {
      const duration = performance.now() - startTime;
      Logger.debug(`‚ö° Performance: ${label}`, { duration: `${duration.toFixed(2)}ms` });
    }
  };

  // Expose logger globally for debugging
  window.AdFixusLogger = Logger;
  
  // === HEIGHT CALCULATION ===
  const MAX_REASONABLE_HEIGHT = 2000; // Cap at 2000px to prevent runaway expansion
  let lastSentHeight = 0;
  let sendCount = 0;
  let heightStableCount = 0;
  
  function getDocHeight() {
    // Get CONTENT height only, not viewport-based calculations
    const root = document.getElementById('root');
    const contentHeight = root ? root.scrollHeight : document.body.scrollHeight;
    
    // Cap at reasonable maximum to prevent feedback loops
    return Math.min(contentHeight, MAX_REASONABLE_HEIGHT);
  }

  function sendHeight(trigger = 'unknown') {
    const startTime = performance.now();
    const height = Math.round(getDocHeight());
    const isInIframe = window.parent && window.parent !== window;
    
    sendCount++;
    
    // Feedback loop detection: if height keeps growing beyond reasonable size
    if (height > lastSentHeight && height > 1500) {
      heightStableCount++;
      if (heightStableCount > 3) {
        Logger.warn('üõë Feedback loop detected, skipping height update', { height, lastSentHeight });
        return;
      }
    } else {
      heightStableCount = 0;
    }
    
    const logData = {
      height,
      previousHeight: lastSentHeight,
      changed: height !== lastSentHeight,
      trigger,
      sendCount,
      isInIframe,
      targetOrigin: PARENT_ORIGIN,
    };
    
    // Only send if meaningfully different (10px threshold)
    if (Math.abs(height - lastSentHeight) < 10) {
      Logger.debug('Height change too small, skipping send', logData);
      return;
    }
    
    lastSentHeight = height;
    
    if (isInIframe) {
      try {
        window.parent.postMessage({ 
          type: 'setHeight', 
          height,
          source: APP_NAME,
          timestamp: Date.now(),
          trigger
        }, PARENT_ORIGIN);
        
        Logger.success(`Height sent to parent: ${height}px`, logData);
      } catch (err) {
        Logger.error('Failed to send height to parent', { error: err.message, ...logData });
      }
    } else {
      Logger.warn('Not in iframe context, height not sent', logData);
    }
    
    Logger.performance('sendHeight()', startTime);
  }

  // === EVENT LISTENERS ===
  Logger.info('üöÄ Iframe communication system initializing', {
    parentOrigin: PARENT_ORIGIN,
    debugMode: DEBUG_MODE,
    userAgent: navigator.userAgent.substring(0, 50) + '...'
  });

  window.addEventListener('load', () => {
    Logger.info('üìÑ Window load event fired');
    sendHeight('window.load');
  });

  // ResizeObserver with throttling
  let resizeTimeout;
  try {
    const ro = new ResizeObserver((entries) => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        Logger.debug('ResizeObserver triggered', { 
          entries: entries.length,
          elements: entries.map(e => e.target.tagName)
        });
        sendHeight('ResizeObserver');
      }, 100); // Throttle to 100ms
    });
    
    ro.observe(document.documentElement);
    ro.observe(document.body);
    Logger.success('‚úÖ ResizeObserver attached successfully');
  } catch (e) {
    Logger.warn('‚ö†Ô∏è ResizeObserver not available, using fallback interval', { error: e.message });
    setInterval(() => sendHeight('interval-fallback'), 1000);
  }

  // Message handler
  window.addEventListener('message', function (ev) {
    Logger.debug('üì® Message received', {
      origin: ev.origin,
      type: ev.data?.type,
      data: ev.data
    });
    
    // Security: validate origin
    if (ev.origin !== PARENT_ORIGIN && ev.origin !== window.location.origin) {
      Logger.warn('üö´ Message from unauthorized origin ignored', { origin: ev.origin });
      return;
    }
    
    if (ev.data && ev.data.type === 'requestHeight') {
      Logger.info('üì• Height request received from parent');
      sendHeight('parent-request');
    }
    
    if (ev.data && ev.data.type === 'ping') {
      Logger.info('üèì Ping received, sending pong');
      window.parent.postMessage({ type: 'pong', source: APP_NAME }, PARENT_ORIGIN);
    }
  });

  // Initial delayed send
  setTimeout(() => {
    Logger.info('‚è±Ô∏è Initial delayed send (500ms)');
    sendHeight('initial-delayed');
  }, 500);

  // Additional delayed send for dynamic content
  setTimeout(() => {
    Logger.info('‚è±Ô∏è Secondary delayed send (1500ms) for dynamic content');
    sendHeight('secondary-delayed');
  }, 1500);

  Logger.success('‚úÖ Iframe communication system initialized', {
    features: ['ResizeObserver', 'postMessage', 'throttling', 'origin-validation']
  });
})();
    </script>
  </body>
</html>
